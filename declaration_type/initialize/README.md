# スカラー型の初期化
ポインター `px` は 0 に初期化され、"null" ポインターが作成されます。
```
register int *px = 0;
```

このステートメントは、`b` を別の変数 `x` のアドレスで初期化します。
```
int *b = &x;
```

ポインター `a` が `z` という名前の変数のアドレスで初期化されます。 ただし、変数 `a` は `const` と指定されているため、初期化はできますが変更はできません。 これは、常に同じ場所を指します。
```
int *const a = &z;
```

グローバル変数 `GLOBAL` は外部レベルで宣言されるため、グローバル有効期間があります。 ローカル変数 `LOCAL` には `auto` ストレージ クラスがあり、このローカル変数を宣言する関数の実行中のみアドレスが存在します。 したがって、`static` ポインター変数 `lp` を `LOCAL` のアドレスで初期化することはできません。 `GLOBAL` のアドレスは常に同じであるため、 `static` ポインター変数 `gp` をこのアドレスに初期化できます。 同様に、`rp` がローカル変数であり、定数でない初期化子を指定できるため、`*rp` は初期化できます。 ブロックが入力されるたびに `LOCAL` に新しいアドレスが割り当てられ、それが `rp` に割り当てられます。
```
int GLOBAL ;

int function( void )
{
    int LOCAL ;
    static int *lp = &LOCAL;   /* Illegal initialization */
    static int *gp = &GLOBAL;  /* Legal initialization   */
    register int *rp = &LOCAL; /* Legal initialization   */
}
```

# 集約型の初期化
構造体、共用体、または配列型のこと。

```
// 以下は同等
int P[4][3] =
{
    { 1, 1, 1 },
    { 2, 2, 2 },
    { 3, 3, 3,},
    { 4, 4, 4,},
};

int P[4][3] =
{
   1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4
};
```

集約変数を初期化するときは、中かっこと初期化子リストを正しく使用する必要があります。 
```
typedef struct
{
    int n1, n2, n3;
} triplet;

triplet nlist[2][3] =
{
    { {  1, 2, 3 }, {  4, 5, 6 }, {  7, 8, 9 } },  /* Row 1 */
    { { 10,11,12 }, { 13,14,15 }, { 16,17,18 } }   /* Row 2 */
};
```

`list` 構造体では、`m` の最初の行の 3 つの要素は `4.0` に初期化されます。`m` の残りの行の要素は、既定で `0.0` に初期化されます。
```
struct list
{
    int i, j, k;
    float m[2][3];
} x = {
        1,
        2,
        3,
       {4.0, 4.0, 4.0}
      };
```

共用体変数 `y` は、この例では初期化されます。 共用体の最初の要素は配列であるため、初期化子は初期化子の集約です。 初期化子リスト `{'1'}` は配列の最初の行に値を割り当てます。 リストには 1 種類の値のみが表示されるため、最初の列の要素は、文字 `1` に初期化され、行の残りの 2 つの要素は、既定で値 0 に初期化されます。 同様に、`x` の 2 番目の行の最初の要素は、文字 `4` に初期化され、行の残りの 2 つの要素は値 0 に初期化されます。
```
union
{
    char x[2][3];
    int i, j, k;
} y = { {
            {'1'},
            {'4'}
        }
      };
```      

# 文字列の初期化
文字の 4 要素配列として `code` を初期化します。 4 番目の要素は、すべての文字列リテラルを終了する null 文字です。
```
char code[ ] = "abc";
```

識別子リストの長さは、初期化される識別子の数と同じだけです。 文字列より短い配列サイズを指定すると、余分な文字は無視されます。 たとえば、次の宣言では、`code` を 3 要素の文字配列として初期化します。
```
char code[3] = "abcd";
```